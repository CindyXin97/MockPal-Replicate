import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authConfig } from '@/lib/auth-config';
import { db } from '@/lib/db';
import { interviewQuestions, userInterviewPosts, users, interviewVotes, interviewComments } from '@/lib/db/schema';
import { and, eq, like, desc, sql } from 'drizzle-orm';

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authConfig);
    
    const { searchParams } = new URL(request.url);
    
    // Ëé∑ÂèñÁ≠õÈÄâÂèÇÊï∞
    const company = searchParams.get('company');
    const position = searchParams.get('position');
    const questionType = searchParams.get('questionType');
    const difficulty = searchParams.get('difficulty');
    const year = searchParams.get('year');
    const includeUserPosts = searchParams.get('includeUserPosts') === 'true';
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const offset = (page - 1) * limit;
    
    // Ëé∑ÂèñÂΩìÂâçÁî®Êà∑ID
    let currentUserId: number | null = null;
    if (session?.user?.email) {
      const userResult = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.email, session.user.email))
        .limit(1);
      if (userResult.length > 0) {
        currentUserId = userResult[0].id;
      }
    }

    // ÊûÑÂª∫Êü•ËØ¢Êù°‰ª∂
    const conditions = [];
    
    if (company && company !== 'all') {
      conditions.push(eq(interviewQuestions.company, company));
    }
    
    if (position && position !== 'all') {
      conditions.push(eq(interviewQuestions.position, position));
    }
    
    if (questionType && questionType !== 'all') {
      conditions.push(eq(interviewQuestions.questionType, questionType));
    }
    
    if (difficulty && difficulty !== 'all') {
      conditions.push(eq(interviewQuestions.difficulty, difficulty));
    }
    
    if (year && year !== 'all') {
      conditions.push(eq(interviewQuestions.year, parseInt(year)));
    }

    // Êü•ËØ¢Á≥ªÁªüÈ¢òÁõÆÊï∞ÊçÆ
    const whereClause = conditions.length > 0 ? and(...conditions) : undefined;
    
    const systemQuestions = await db
      .select()
      .from(interviewQuestions)
      .where(whereClause)
      .orderBy(desc(interviewQuestions.year), desc(interviewQuestions.createdAt));
    
    console.log(`üìä Êü•ËØ¢Âà∞Á≥ªÁªüÈ¢òÁõÆÊï∞: ${systemQuestions.length}`);

    // Â¶ÇÊûúÂåÖÂê´Áî®Êà∑ÂèëÂ∏ñÔºåÊü•ËØ¢Áî®Êà∑ÂèëÂ∏ÉÁöÑÈ¢òÁõÆ
    let userPosts: any[] = [];
    let ownPosts: any[] = [];
    
    if (includeUserPosts) {
      try {
        // ÊûÑÂª∫Áî®Êà∑È¢òÁõÆÁöÑÊü•ËØ¢Êù°‰ª∂
        const userPostConditions = [eq(userInterviewPosts.status, 'active')];
        
        if (company && company !== 'all') {
          userPostConditions.push(eq(userInterviewPosts.company, company));
        }
        
        if (position && position !== 'all') {
          userPostConditions.push(eq(userInterviewPosts.position, position));
        }
        
        if (questionType && questionType !== 'all') {
          userPostConditions.push(eq(userInterviewPosts.questionType, questionType));
        }
        
        if (difficulty && difficulty !== 'all') {
          userPostConditions.push(eq(userInterviewPosts.difficulty, difficulty));
        }

        const userPostWhereClause = userPostConditions.length > 0 ? and(...userPostConditions) : undefined;
        
        // Êü•ËØ¢Áî®Êà∑ÂèëÂ∏ÉÁöÑÈ¢òÁõÆ
        const allUserPosts = await db
          .select({
            id: userInterviewPosts.id,
            userId: userInterviewPosts.userId,
            company: userInterviewPosts.company,
            position: userInterviewPosts.position,
            questionType: userInterviewPosts.questionType,
            difficulty: userInterviewPosts.difficulty,
            question: userInterviewPosts.question,
            recommendedAnswer: userInterviewPosts.recommendedAnswer,
            isAnonymous: userInterviewPosts.isAnonymous,
            viewsCount: userInterviewPosts.viewsCount,
            createdAt: userInterviewPosts.createdAt,
            interviewDate: userInterviewPosts.interviewDate,
            userName: users.name,
            userEmail: users.email,
          })
          .from(userInterviewPosts)
          .leftJoin(users, eq(userInterviewPosts.userId, users.id))
          .where(userPostWhereClause)
          .orderBy(desc(userInterviewPosts.createdAt));

        // ÂàÜÁ¶ªÂΩìÂâçÁî®Êà∑ÁöÑÂ∏ñÂ≠êÂíåÂÖ∂‰ªñÁî®Êà∑ÁöÑÂ∏ñÂ≠ê
        if (currentUserId) {
          ownPosts = allUserPosts
            .filter((post) => post.userId === currentUserId)
            .map((post) => ({
              ...post,
              postType: 'user',
              year: new Date(post.interviewDate).getFullYear(),
              isOwnPost: true,
            }));
          
          const otherUserPosts = allUserPosts
            .filter((post) => post.userId !== currentUserId)
            .map((post) => ({
              ...post,
              postType: 'user',
              year: new Date(post.interviewDate).getFullYear(),
              isOwnPost: false,
            }));
          
          // ÂØπÂÖ∂‰ªñÁî®Êà∑ÁöÑÂ∏ñÂ≠êÊåâÁÉ≠Â∫¶ÊéíÂ∫è
          const userPostsWithStats = await Promise.all(
            otherUserPosts.map(async (post) => {
              const postType = 'user';
              const postId = post.id;

              // Ëé∑ÂèñÊäïÁ•®ÁªüËÆ°
              const upvotesResult = await db
                .select({ count: sql<number>`count(*)` })
                .from(interviewVotes)
                .where(
                  and(
                    eq(interviewVotes.postType, postType),
                    eq(interviewVotes.postId, postId),
                    eq(interviewVotes.voteType, 'up')
                  )
                );

              const downvotesResult = await db
                .select({ count: sql<number>`count(*)` })
                .from(interviewVotes)
                .where(
                  and(
                    eq(interviewVotes.postType, postType),
                    eq(interviewVotes.postId, postId),
                    eq(interviewVotes.voteType, 'down')
                  )
                );

              // Ëé∑ÂèñËØÑËÆ∫Êï∞
              const commentsResult = await db
                .select({ count: sql<number>`count(*)` })
                .from(interviewComments)
                .where(
                  and(
                    eq(interviewComments.postType, postType),
                    eq(interviewComments.postId, postId)
                  )
                );

              const upvotes = upvotesResult[0]?.count || 0;
              const downvotes = downvotesResult[0]?.count || 0;
              const comments = commentsResult[0]?.count || 0;
              const score = upvotes - downvotes;
              
              // ÁÉ≠Â∫¶ËÆ°ÁÆóÔºöscore * 2 + commentsÔºàÁÇπËµûÊùÉÈáçÊõ¥È´òÔºâ
              const hotness = score * 2 + comments;

              return {
                ...post,
                tempStats: { upvotes, downvotes, comments, score, hotness }
              };
            })
          );

          // ÊåâÁÉ≠Â∫¶ÊéíÂ∫èÁî®Êà∑Â∏ñÂ≠êÔºàÁÉ≠Â∫¶È´òÁöÑÂú®ÂâçÔºâ
          userPosts = userPostsWithStats.sort((a, b) => {
            return (b.tempStats?.hotness || 0) - (a.tempStats?.hotness || 0);
          });

          console.log('üìä ÂÖ∂‰ªñÁî®Êà∑ÂèëÂ∏ÉÁöÑÈ¢òÁõÆÂ∑≤ÊåâÁÉ≠Â∫¶ÊéíÂ∫è');
        } else {
          userPosts = allUserPosts.map((post) => ({
            ...post,
            postType: 'user',
            year: new Date(post.interviewDate).getFullYear(),
            isOwnPost: false,
          }));
        }
        
        console.log(`üìä Êü•ËØ¢Âà∞Áî®Êà∑ÂèëÂ∏ÉÈ¢òÁõÆÊï∞: ${allUserPosts.length}`);
      } catch (error) {
        console.error('‚ö†Ô∏è Êü•ËØ¢Áî®Êà∑ÂèëÂ∏ÉÈ¢òÁõÆÂ§±Ë¥•ÔºàË°®ÂèØËÉΩ‰∏çÂ≠òÂú®ÔºåÂ∞ÜÂè™ÊòæÁ§∫Á≥ªÁªüÈ¢òÁõÆÔºâ:', error);
        // Â¶ÇÊûúÊü•ËØ¢Â§±Ë¥•ÔºàÊØîÂ¶ÇË°®‰∏çÂ≠òÂú®ÔºâÔºåÁªßÁª≠‰ΩøÁî®Á©∫Êï∞ÁªÑÔºå‰∏çÂΩ±ÂìçÁ≥ªÁªüÈ¢òÁõÆÊòæÁ§∫
      }
    }

    // Ê†áËÆ∞Á≥ªÁªüÈ¢òÁõÆ
    const systemQuestionsWithType = systemQuestions.map((q) => ({
      ...q,
      postType: 'system',
      isOwnPost: false,
    }));

    // Â¶ÇÊûúÂêØÁî®Áî®Êà∑ÂèëÂ∏ñÔºåÈúÄË¶ÅÂÖàËé∑ÂèñÊâÄÊúâÈ¢òÁõÆÁöÑstatsÔºåÁÑ∂ÂêéÂØπÁ≥ªÁªüÈ¢òÁõÆÊåâÁÉ≠Â∫¶ÊéíÂ∫è
    let sortedSystemQuestions = systemQuestionsWithType;
    
    if (includeUserPosts) {
      try {
        // Ëé∑ÂèñÊâÄÊúâÁ≥ªÁªüÈ¢òÁõÆÁöÑÁªüËÆ°Êï∞ÊçÆ
        const systemQuestionsWithStats = await Promise.all(
          systemQuestionsWithType.map(async (question) => {
            const postType = 'system';
            const postId = question.id;

            // Ëé∑ÂèñÊäïÁ•®ÁªüËÆ°
            const upvotesResult = await db
              .select({ count: sql<number>`count(*)` })
              .from(interviewVotes)
              .where(
                and(
                  eq(interviewVotes.postType, postType),
                  eq(interviewVotes.postId, postId),
                  eq(interviewVotes.voteType, 'up')
                )
              );

            const downvotesResult = await db
              .select({ count: sql<number>`count(*)` })
              .from(interviewVotes)
              .where(
                and(
                  eq(interviewVotes.postType, postType),
                  eq(interviewVotes.postId, postId),
                  eq(interviewVotes.voteType, 'down')
                )
              );

            // Ëé∑ÂèñËØÑËÆ∫Êï∞
            const commentsResult = await db
              .select({ count: sql<number>`count(*)` })
              .from(interviewComments)
              .where(
                and(
                  eq(interviewComments.postType, postType),
                  eq(interviewComments.postId, postId)
                )
              );

            const upvotes = upvotesResult[0]?.count || 0;
            const downvotes = downvotesResult[0]?.count || 0;
            const comments = commentsResult[0]?.count || 0;
            const score = upvotes - downvotes;
            
            // ÁÉ≠Â∫¶ËÆ°ÁÆóÔºöscore * 2 + commentsÔºàÁÇπËµûÊùÉÈáçÊõ¥È´òÔºâ
            const hotness = score * 2 + comments;

            return {
              ...question,
              tempStats: { upvotes, downvotes, comments, score, hotness }
            };
          })
        );

        // ÊåâÁÉ≠Â∫¶ÊéíÂ∫èÁ≥ªÁªüÈ¢òÁõÆÔºàÁÉ≠Â∫¶È´òÁöÑÂú®ÂâçÔºâ
        sortedSystemQuestions = systemQuestionsWithStats.sort((a, b) => {
          return (b.tempStats?.hotness || 0) - (a.tempStats?.hotness || 0);
        });

        console.log('üìä Á≥ªÁªüÈ¢òÁõÆÂ∑≤ÊåâÁÉ≠Â∫¶ÊéíÂ∫è');
      } catch (error) {
        console.error('‚ö†Ô∏è Ëé∑ÂèñÁ≥ªÁªüÈ¢òÁõÆÁªüËÆ°Â§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§ÊéíÂ∫è:', error);
      }
    }

    // ÂêàÂπ∂ÊâÄÊúâÈ¢òÁõÆÔºöÊàëÁöÑÂèëÂ∏É > ÂÖ∂‰ªñÁî®Êà∑ÂàÜ‰∫´ > Á≥ªÁªüÁ≤æÈÄâÔºàÊåâÁÉ≠Â∫¶Ôºâ
    let allQuestions = [...ownPosts, ...userPosts, ...sortedSystemQuestions];

    // Ëé∑ÂèñÊäïÁ•®ÂíåËØÑËÆ∫ÁªüËÆ°Ôºà‰∏∫ÂàÜÈ°µÂêéÁöÑÈ¢òÁõÆÊ∑ªÂä†ÂÆåÊï¥statsÂíåuserVoteÔºâ
    let questionsWithStats = allQuestions.slice(offset, offset + limit);
    
    if (includeUserPosts) {
      // Âè™ÊúâÂêØÁî®Áî®Êà∑ÂèëÂ∏ñÊó∂ÊâçÊü•ËØ¢ÁªüËÆ°Êï∞ÊçÆ
      try {
        questionsWithStats = await Promise.all(
          allQuestions.slice(offset, offset + limit).map(async (question) => {
            const postType = question.postType;
            const postId = question.id;

            // Ëé∑ÂèñÊäïÁ•®ÁªüËÆ°
            const upvotesResult = await db
              .select({ count: sql<number>`count(*)` })
              .from(interviewVotes)
              .where(
                and(
                  eq(interviewVotes.postType, postType),
                  eq(interviewVotes.postId, postId),
                  eq(interviewVotes.voteType, 'up')
                )
              );

            const downvotesResult = await db
              .select({ count: sql<number>`count(*)` })
              .from(interviewVotes)
              .where(
                and(
                  eq(interviewVotes.postType, postType),
                  eq(interviewVotes.postId, postId),
                  eq(interviewVotes.voteType, 'down')
                )
              );

            // Ëé∑ÂèñËØÑËÆ∫Êï∞
            const commentsResult = await db
              .select({ count: sql<number>`count(*)` })
              .from(interviewComments)
              .where(
                and(
                  eq(interviewComments.postType, postType),
                  eq(interviewComments.postId, postId)
                )
              );

            // Ëé∑ÂèñÂΩìÂâçÁî®Êà∑ÁöÑÊäïÁ•®Áä∂ÊÄÅ
            let userVote = null;
            if (currentUserId) {
              const userVoteResult = await db
                .select({ voteType: interviewVotes.voteType })
                .from(interviewVotes)
                .where(
                  and(
                    eq(interviewVotes.userId, currentUserId),
                    eq(interviewVotes.postType, postType),
                    eq(interviewVotes.postId, postId)
                  )
                )
                .limit(1);

              if (userVoteResult.length > 0) {
                userVote = userVoteResult[0].voteType;
              }
            }

            const upvotes = upvotesResult[0]?.count || 0;
            const downvotes = downvotesResult[0]?.count || 0;
            const comments = commentsResult[0]?.count || 0;

            // ÁßªÈô§‰∏¥Êó∂stats
            const { tempStats, ...cleanQuestion } = question as any;

            return {
              ...cleanQuestion,
              stats: {
                upvotes,
                downvotes,
                score: upvotes - downvotes,
                comments,
                views: question.viewsCount || 0,
              },
              userVote,
            };
          })
        );
      } catch (error) {
        console.error('Error fetching stats:', error);
        // Â¶ÇÊûúÁªüËÆ°Êü•ËØ¢Â§±Ë¥•ÔºåËøîÂõûÊ≤°ÊúâÁªüËÆ°‰ø°ÊÅØÁöÑÈ¢òÁõÆ
      }
    }

    const total = allQuestions.length;
    
    console.log(`üìä ÊÄªÈ¢òÁõÆÊï∞: ${total}, ÂΩìÂâçÈ°µ: ${page}, ËøîÂõûÈ¢òÁõÆÊï∞: ${questionsWithStats.length}`);

    // Ëé∑ÂèñÁ≠õÈÄâÈÄâÈ°πÊï∞ÊçÆ
    const companiesResult = await db
      .selectDistinct({ company: interviewQuestions.company })
      .from(interviewQuestions)
      .orderBy(interviewQuestions.company);
    
    const positionsResult = await db
      .selectDistinct({ position: interviewQuestions.position })
      .from(interviewQuestions)
      .orderBy(interviewQuestions.position);
    
    const yearsResult = await db
      .selectDistinct({ year: interviewQuestions.year })
      .from(interviewQuestions)
      .orderBy(desc(interviewQuestions.year));

    const companies = companiesResult.map(r => r.company);
    const positions = positionsResult.map(r => r.position);
    const years = yearsResult.map(r => r.year);

    return NextResponse.json({
      success: true,
      data: {
        questions: questionsWithStats,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        },
        filters: {
          companies,
          positions,
          years,
          questionTypes: ['technical', 'behavioral', 'case_study', 'stats'],
          difficulties: ['easy', 'medium', 'hard']
        },
        currentUserId,
      }
    });
  } catch (error) {
    console.error('Error fetching interview questions:', error);
    return NextResponse.json(
      { success: false, message: 'Ëé∑ÂèñÈù¢ËØïÁúüÈ¢òÂ§±Ë¥•' },
      { status: 500 }
    );
  }
} 